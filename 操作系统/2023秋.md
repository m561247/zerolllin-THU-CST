#### 2023 秋

##### （一）

1. F，只能在内核态
2. T，我现在觉得是回收旧的，创建新的
3. T
4. F，孤儿进程，挂在 root 进程下
5. F，通过 a0-a6 寄存器传递参数，a7 传递系统调用编号，a0 传递返回值
6. F，只有设置异常委托才在 S 态处理异常，也可能在 M 态执行
7. F，stval
8. T
9. F，medeleg 异常委托
10. T

##### （二）

11. 1. 指令访存，3 级页表均不在内存中，造成 3 次 page fault。访问数据时，3 级页表均不在内存中，造成 3 次 page fault。总共最多造成 6 次 page fault

    2. 最多造成 3 + 8 * 3 = 27 次 Page Fault

       页面大小 4096 时，rs2 取 1360（4096/3），rs1 任取有效的 8 字节对齐的虚拟地址

       页表有效性：第 1 次，第 4 次，第 7 次访存时，leaf PTE 无效，其他时候有效

    3. Load Address Misaligned

12. 1. FCFS：进程到达时间越早，在队列中位置约靠前，越先被调度
    2. SJF：任务估计运行时间越短，队列中越靠前，越先被调度
    3. HRRN：任务响应比 R = (w + s)/s，s 为运行时间，w 为等待时间
    4. RM：运行时间越短，越先被调度
    5. EDF：截止时间越早，越先被调度
    6. LLF：任务松弛度 = 必须完成时间 - 本身还需要运行时间 - 当前时间，松弛度越低，越先被调度

14. 1. 两级页号各占 5 位，页偏移占 5 位

    2. 硬件：设置 sepc 为引发缺页异常的当前 PC，stval 为访问的虚拟地址，sstatus SPP 为当前特权级，特权级设为 S，PC 跳转到 stvec 执行

       软件：跳转到 stvec 处执行内核代码，首先保存引发异常的进程 Trap Context 到内核栈，跳转到 trap_handler 异常处理程序，从磁盘上读取访问物理页的内容，更新页表，从内核栈中恢复进程 Trap Context，恢复 sp 为应用上下文栈帧位置，通过 sret 指令回到用户态执行用户态程序


15. 1. S 态

    2. 在初始化进程块时，我们设置了 stvec 为 \_\_alltraps 地址。发生异常/中断后，硬件会跳转到 stvec 对应地址执行。

    3. 交换后 sp 为内核栈栈顶位置。

    4. 在内核栈开辟空间，保存通用寄存器。

    5. 在内核栈保存 sstatus，sepc 的值。

       不能，因为需要先保存 t0，t1 之前的值，才能使用这两个寄存器。

