#### 2023 春

##### （一）

1. F，Android 和 IOS 都是基于 Linux 的宏内核架构
2. T
3. T
4. F，操作系统自己不需要堆空间
5. F
6. T
7. F
8. F，二进制代码中没有堆栈
9. T
10. T
11. F
12. F
13. F，一直在运行态
14. T，安全性，缓冲区溢出攻击
15. T，sepc 和 sstatus

##### （二）

1. - FCFS：操作系统优先调度到达时间早的进程
     - 优点：实现简单，不存在公平性问题
     - 缺点：进程平均等待时间长，CPU 资源和 I/O 资源利用不充分
   - SJF：操作系统优先调度运行时间短的进程
     - 优点：平均等待时间最短
     - 缺点：无法准确预测进程的运行时间，长进程可能一直处于饥饿状态
   - SRT：操作系统优先调度剩余时间最短的进程，允许抢占式调度
   - HRRN：操作系统优先调度响应比最高的进程，响应比 R = (w + s)/s，其中 w 为等待时间，s 为运行时间
     - 综合考虑进程的就绪等待时间和预期运行时间，防止无限延期
   - 是。采用反证法。假设另一个调度序列具有更短平均周转时间。

2. - 是，sfence.vma 指令

   - 更新 satp 寄存器从而更换页表时

   - 不需要，因为 Cache 是 VIPT，是用物理地址寻址的

   - 跳板页，包含 \_\_alltraps 函数和 \_\_restore 函数，跳板页在用户地址空间和内核地址空间映射到同样的物理地址，从而可以仅借助 sscratch 一个中转寄存器，同时完成 satp 和栈帧的切换。

   - alltraps 函数中，从 sscratch 得到 TrapContext 地址，从 TrapContext 中恢复 kernel satp 以及进程的 kernel stack sp，将用户栈 sp 保存到 TrapContext 中

     restore 函数中，user satp 和 TrapContext 地址作为参数传递，从 TrapContext 恢复用户栈 sp，将 TrapContext 地址暂存在 sscratch 中

     alltraps 或 restore 函数中，先修改 satp（此时页表已经切换，但 trampoline 映射到的物理地址不变），再恢复 sp 为用户地址空间中的 TrapContext 地址或内核地址空间中的 kernel stack sp

3. 1.  LRU：维护页面按照上次访问时间排序的页面链表，选择最长时间没有访问的页面进行置换

      - 开销大，性能好

      FIFO：选择在内存中驻留时间最长的页面进行置换
      - 实现简单，性能较差

      Clock：维护页表项的访问位，对页面在最近一段时间内的访问情况进行统计，选择置换页面时遍历环形列表，根据访问位情况进行置换或修改访问位

      - 性能和开销是 LRU 和 FIFO 的折中

      工作集置换算法：将不在某一时钟窗口大小的工作集中的页面换出内存

      缺页率置换算法：记录缺页时间到上次缺页时间的时间间隔，大于某个容忍阈值时，就将这段时间内未访问的页面都置换出内存

   2. 需要维护按照最近一次访问时间排序的页面链表，或者维护当前的活动页面栈，算法复杂度高

   3. 因为 LRU 算法是**堆栈类算法**，并且 LRU 算法选择置换页面的特征与页面访问的动态特征是一致的。

   4. 共产生 8 次缺页，分别产生于第 1，2，3，4，7，9，12，13 次访存

   5. 共产生 8 次缺页，分别产生于第 1，2，3，4，7，9，12，13 次访存

   6. 执行时机：物理内存不够分配新的页面，而需要从进程已分配的页面中回收时

      Clock 算法访问 PTE 的 A（Access）和 D（Dirty）位，他们分别记录了在最近一段时间内对内存中页面的访问和修改情况

      在访问页面时，将 PTE 的 A 位置为 1，对页面进行写回操作时，将 D 位也置为 1

      选择页面置换时，遍历环形链表，对于 A、D 位均为 1 的页面，将 A、D 位分别设为 0、1；对于 A、D 位为 0、1 或 1、0 的页面，将 A、D 位都设为 0；对于 A、D 位均为 0 的页面，选择将页面从内存中置换到外存中